# 简答题

（请直接在本文件中作答）

## 1、Vue 3.0 性能提升主要是通过哪几方面体现的？

1. 数据劫持方式由 Object.defineProperty 变成 Proxy, 避免了对data对象的递归处理;
2. 静态根节点提升, 使diff时需要比较的节点数减少;
3. 更好的 tree-shaking, 排除了对用不到的代码的加载工作, 减小了打包体积;
4. 去掉了不常用的api, 减小了打包后的体积;

## 2、Vue 3.0 所采用的 Composition Api 与 Vue 2.x使用的Options Api 有什么区别？

1. 将有关联的业务逻辑(数据/方法/钩子/watcher等)集中到同一个use函数中, 避免数据/方法/监听等逻辑散落在配置对象的各处;
2. 数据需要由用户手动调用reactive或ref/toRefs来转换成响应式;
3. watchEffect 的功能相当于将其回调中用到的响应式数据全部添加watcher, 减少了代码量;

## 3、Proxy 相对于 Object.defineProperty 有哪些优点？

1. 不用递归调用, 对子属性的变动可以监听到;
2. 可以监听到动态添加的属性的变更;
3. 可以监听到数组索引的变更;
4. 可以监听到数组length的变化;

## 4、Vue 3.0 在编译方面有哪些优化？

1. 标记和提升静态节点, diff时跳过静态根节点的比较;
2. 重用静态节点, 无需重新创建节点;
3. 根据 patchFlag 只对比可能发生变化的属性;
4. 缓存事件处理函数;

## 5、Vue.js 3.0 响应式系统的实现原理？

- 创建一个 targetMap, 用来记录目标对象和 depsMap 的对应关系, 在 depsMap 中记录目标对象所有的属性对应的 deps, 在 deps 中保存属性变更时需要触发的所有回调函数;
- 代理对象时在 get 中添加收集依赖的逻辑, 当 get 触发时执行依赖收集;
- 在 watchEffect 中先执行传入的回调, 触发回调中的数据的 get, 并记录此回调到属性的 deps 中.
- 依赖收集时查询 targetMap, depsMap 和 deps 如果不存在, 则创建出来;
- 在代理对象的 set 中找到 属性的 deps, 触发所有的回调函数;
